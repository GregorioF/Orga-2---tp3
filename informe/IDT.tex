\section{IDT}
\label{subsec:IDT}
\par{La IDT, Interruption Descriptor Table, se encarga de almacenar descriptores de rutinas de atención sobre interrpuciones de software, de hardware, y expeciones. Este se representa como un arreglo de maximo 2**13 entradas, de tamaño 64 bits. Estos Descriptores cargan informacion sobre, donde se hubica dicha rutina de atencion, atributos de presente, o DPL (nivel de privilegio requerido para acceder a dicha interrupcion), y el selector de segmento que se va a utilizar, en general este selector es el de Código nivel 0, ya que una interrpucion suele necesitar de accesos a nivel Kernel.}

\subsection{Rellenado de IDT}
\begin{itemize}
	\item {\bfseries Expeciones: }
	\par{Por restricciones de Intel, desde la posicion 0 hasta la 19 es donde se van a hubicar los descriptores de rutinas de atencion sobre expeciones, segun el orden que indica el manual de Intel. Estas tienen los atributos de presente en 1 y el DPL en 3, pues no queremos que ninguna tarea de nivel usuario llame a una Exepcion intencionalmente. Luego las entradas entre la 20 y la 31 estan reservadas a futuras posible exepciones, o usos que Intel les proporcione.}
	
	\item {\bfseries Interrupciones de Hardware: }
	\par{ Estas se ubican en las primeras entradas libres a partir de la 32, en particular la 32 es la interrupcion de Reloj, y la 33 la interrupcion de teclado. Ambas entradas en nuestro TP estan seteadas con el SegSel = Cod\_L0, el bit de presente en 1, y DPL = 0.}
	
	\item {\bfseries Interrpuciones de Software: }
	\par{Estas son seteadas a partir de posiciones mayores, en nuestro caso implementamos 2, en la entrada 80 y en la entrada 102. Donde la unica diferencia con las de Hardware respecto a los atributos, es que estas contienen DPL = 3, ya que queremos que puedan ser llamadas por tareas nivel usuario para ejecutar un codigo en nivel 0, esto en particular se le da el nombre de syscall.}

\end{itemize}

\subsection{Proceso de identificación de interrupción requerida}
\par{Cuando ocurre una interrpcion / exepción, el proceso basicamente es obtener el descriptor de interrupcion señalado por el Vector de Interrpciones, y de ahi saltar directamente a la rutina de atención. Ahora la forma en la que se carga dicho Vector es, para expeciones, el mismo procesador se encarga de indentificar cual es la posicion asignada a dicha interrupcion, dentro de la IDT segun Intel, y carga el vector con dicho valor.  Para interrupciones de Hardware se utiliza lo que es el PIC de interrupciones donde cuando un elemento externo solicita una interrpucion, estos estan ordenados en un orden especifico segun un handler de hardware, y este identifica cual de los aparatos fue el que la solicito, cargando de esta manera al Vector de Interrupciones. Y por último a una interrpucion de Software simplemente es el numero q le sigue a la instruccion "int" que es la utilizada para solicitar una interrpucion especifica.}

\subsection{Excepciones}
\par{La rutina de atención a las excepciones es común a todos ellas. Esta se encarga de deshabilitar la tarea que ha caído en la interrupción, almacenar la información de la pila, y saltar a la tarea idle.}
\par{Para esto simplemente llamamos a la función \textbf{deshabilitar$\_$tarea} con el índice del navío o la bandera que haya producido el error.}
\subsection{Interrupción de reloj}
\par{La rutina de atención a la interrupción de reloj llama a otras dos funciones; proximo$\_$reloj y sched. La primera se encarga de la animación del relojito de cada tarea. Sched se encarga de saltar a la siguiente tarea, ya sea un navío o una bandera.}
\par{Cuenta con un contador el cual determina cuándo es momento de ejecutar todas las banderas y las funciones sched$\_$proximo$\_$indice y sched$\_$proxima$\_$bandera las cuales son explicadas es la sección \ref{subsec:Scheduler}.}
\par{De esta manera sched pide el siguiente indice (de navío o bandera según corresponda) y salta a la tarea a la que este refiere. También contamos con un contador de tareas habilitadas, cuando este llega a 0 sched simplemente se limita a saltar a la tarea idle.}
\subsection{Interrupción de teclado}
\par{La interrupción 33 es la que se encarga del teclado, en nuestro caso sólo nos interesan 2 teclas de éste, \textbf{M} y \textbf{E}. La M nos muestra el mapa del juego, y la E el estado de los navíos y las banderas flameando.}
\par{A continuación presentamos un pseudocódigo de la rutina de atención a la int 33.}
\begin{lstlisting}[language={[x86masm]Assembler}]
global _isr33
_isr33:
    pushad
    xor eax, eax
    in al, 0x60
    push eax
    call print_numerito
    add esp, 4
    call fin_intr_pic1
    popad
    iret
\end{lstlisting}
\par{La instrucción \textbf{in al, 0x60} guarda en al el scan code almacenado en el puerto 0x60 y luego utilizamos esta información para escribir en pantalla con la función \textbf{print$\_$numerito}.}
\par{Esta función se encargará de llamar a las funciones auxiliares necesarias para cumplir con lo establecido al principio de esta sección, mostrar el mapa si se presionó la tecla M, y la información de estados si fue la E.}
\par{Las funcione encargada de imprimir en pantalla el mapa utiliza la información almacenada en posicionTareas, el cual es una matriz de 8x3, la cual guarda la posición de la pantalla en la que se encuentra cada página de cada tarea, esto se actualiza en la función actualizar$\_$mapa y también el valor de últimoMisil. La función encargada de imprimir la pantalla de estados utiliza la matriz paginasTareas, la matriz flags, el valor de ultimoError y la matriz de debug entre otras cosas. La primera, lamentamos si confunde su nombre, es una matriz que contiene las posiciones de cada pagina de cada tarea, pero estas en lugar de estar almacenadas como enteros, son una cadena de caracteres, de esta forma nos es más sencillo imprimirlos en la pantalla de estados. La información de la matriz debug nos la provee la pila cuando se produce algún error o alguna interrupción externa. Y en ultimoError se nos informa cuál fue el último error cometido, como bien nos dice su nombre.}
\subsection{Int 80 (0x50)}
\par{Esta es una syscall que sólo pueden utilizar los navíos, es conciderado un error si una bandera la llama. Esta syscall cuenta con 3 funcionalidades; \textbf{navegar}, \textbf{fondear} y \textbf{cañonear}. Depende de los parámetros con los que es llamada se ejecutan las distintas funcionalidades.}
\par{A continuación presentamos un pseudocódigo de la rutina de atención a la interrupción, lo presentamos en lenguaje C para hacer más sencillo su entendimiento.}

\begin{algorithmic}
	\If{EAX == 0xAEF}
	\State navegar(current, cr3, ebx, ecx)
	\EndIf
	\If{EAX == 0x923}
		\State fondear(current, ebx, cr3)
	\EndIf
	\If{EAX == 0x83A}
	\State cañonear(current, ebx, ecx)
	\EndIf
\end{algorithmic}

\subsubsection{Navegar}
\par{Como su nombre lo indica, consiste en moverse a través del espacio marítimo, el cual en nuestro caso consiste en el espacio de memoria entre la dirección 0x100000 y la dirección 0x77FFFF. Los parámetros son 2 direcciones \textbf{físicas} las cuales serán mapeadas a las 2 páginas del navío respectivamente.}
\par{Para llamar a esta funcionalidad se debe escribir en EAX, 0xAEF. En EBX y ECX se pasan las direcciones físicas antes mencionadas.}
\par{A continuación presentamos un pseudocógido de la función navegar.}

\begin{algorithm}[h!]
\caption{void navegar(uint current, uint cr3, uint ebx, uint ecx)}
\begin{algorithmic}
	\State destinoPag1 = (unsigned char*) ebx
	\State destinoPag2 = (unsigned char*) ecx
	\State pagina1TareaActual = (unsigned char*) 0x40000000
	\State pagina2TareaActual = (unsigned char*) 0x40001000
	\For{ $i \gets 0~..~4095$ }
		\State destinoPag1[i] $\gets$ pagina1TareaActual
		\State destinoPag2[i] $\gets$ pagina2TareaActual
	\EndFor

	\State mmu$\_$mapear$\_$pagina(0x40000000, cr3, ebx)
	\State mmu$\_$mapear$\_$pagina(0x40001000, cr3,ecx)
	
	\State actualizar$\_$mapa(ebx,ecx,1,current)
	
\end{algorithmic}
\end{algorithm}


\subsubsection{Fondear}
\par{Esta funcionalidad consiste en mover el ancla de lugar, y en nuestro TP consiste puntualmente en mapear la página asociada al kernel de nuestra tarea a otra dirección física entre el rango de 0x0x000000 hasta 0x0FFFFF.}
\par{Como ya vimos para llamar esta función EAX debe ser 0x923, y en EBX debemos pasar la nueva dirección \textbf{física} a mapear.}
\par{A continuación presentamos un pseudocógido de la función fondear.}

\begin{algorithm}[h!]
\caption{void fondear(uint current, uint ebx, uint cr3)}
\begin{algorithmic}
	\State mmu$\_$mapear$\_$pagina(0x40002000,ebx,cr3)
	\State actualizar$\_$mapa(ebx,0,0,current)
\end{algorithmic}
\end{algorithm}
\subsubsection{Cañonear}
\par{Cada uno de nuestros navíos cuenta con un cañon con el cual lanzar misiles. A esta funcionalidad se accede con EAX==0x83A y consiste en escribir 97 bytes desde la dirección pasada por EBX.}
\par{A continuación presentamos un pseudocógido de la función fondear.}

\begin{algorithm}[h!]
\caption{void canonear(uint current, uint ebx, uint ecx)}
\begin{algorithmic}
	\State misil = (unsigned char*) ecx
	\State destino = (unsigned char*) ebx
	\For (i $\gets 0~..~96$ )
	\State destino[i] $\gets$ misil[i]
	\EndFor
	\State actualizar$\_$mapa(ebx,0,2,current);
\end{algorithmic}
\end{algorithm}


	
\subsection{Int 102 (0x66)}
\par{Esta syscall se encarga de salir de las banderas y saltar a la tarea idle. También se fija que ha sido llamada por una bandera y no por un navío, ya que si fue así, a este habrá que eliminarlo del scheduler junto con su bandera. Para esto llamamos a la función \textbf{inhabilitar$\_$tarea} con el índice actual y también almacenamos la información de la pila para poder mostrarlo por pantalla en la sección de estados.}