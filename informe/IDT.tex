\section{IDT}
\label{subsec:IDT}
\par{La IDT, Interruption Descriptor Table, se encarga de almacenar descriptores de rutinas de atención sobre interrpuciones de software, de hardware, y expeciones. Este se representa como un arreglo de maximo 2**13 entradas, de tamaño 64 bits. Estos Descriptores cargan informacion sobre, donde se hubica dicha rutina de atencion, atributos de presente, o DPL (nivel de privilegio requerido para acceder a dicha interrupcion), y el selector de segmento que se va a utilizar, en general este selector es el de Código nivel 0, ya que una interrpucion suele necesitar de accesos a nivel Kernel.}

\subsection{Rellenado de IDT}
\begin{itemize}
	\item {\bfseries Expeciones: }
	\par{Por restricciones de Intel, desde la posicion 0 hasta la 19 es donde se van a hubicar los descriptores de rutinas de atencion sobre expeciones, segun el orden que indica el manual de Intel. Estas tienen los atributos de presente en 1 y el DPL en 3, pues no queremos que ninguna tarea de nivel usuario llame a una Exepcion intencionalmente. Luego las entradas entre la 20 y la 31 estan reservadas a futuras posible exepciones, o usos que Intel les proporcione.}
	
	\item {\bfseries Interrupciones de Hardware: }
	\par{ Estas se ubican en las primeras entradas libres a partir de la 32, en particular la 32 es la interrupcion de Reloj, y la 33 la interrupcion de teclado. Ambas entradas en nuestro TP estan seteadas con el SegSel = Cod\_L0, el bit de presente en 1, y DPL = 0.}
	
	\item {\bfseries Interrpuciones de Software: }
	\par{Estas son seteadas a partir de posiciones mayores, en nuestro caso implementamos 2, en la entrada 80 y en la entrada 102. Donde la unica diferencia con las de Hardware respecto a los atributos, es que estas contienen DPL = 3, ya que queremos que puedan ser llamadas por tareas nivel usuario para ejecutar un codigo en nivel 0, esto en particular se le da el nombre de syscall.}

\end{itemize}

\subsection{Proceso de identificación de interrupción requerida}
\par{Cuando ocurre una interrpcion / exepción, el proceso basicamente es obtener el descriptor de interrupcion señalado por el Vector de Interrpciones, y de ahi saltar directamente a la rutina de atención. Ahora la forma en la que se carga dicho Vector es, para expeciones, el mismo procesador se encarga de indentificar cual es la posicion asignada a dicha interrupcion, dentro de la IDT segun Intel, y carga el vector con dicho valor.  Para interrupciones de Hardware se utiliza lo que es el PIC de interrupciones donde cuando un elemento externo solicita una interrpucion, estos estan ordenados en un orden especifico segun un handler de hardware, y este identifica cual de los aparatos fue el que la solicito, cargando de esta manera al Vector de Interrupciones. Y por último a una interrpucion de Software simplemente es el numero q le sigue a la instruccion "int" que es la utilizada para solicitar una interrpucion especifica.}

\subsection{Excepciones}
\par{ESTA ME DA IGUAL}
\subsection{Interrupción de reloj}
\subsection{Interrupción de teclado}
\par{La interrupción 33 es la que se encarga del teclado, en nuestro caso sólo nos interesan 2 teclas de éste, \textbf{M} y \textbf{E}. La M nos muestra el mapa del juego, y la E el estado de los navíos y las banderas flameando.}
\par{A continuación presentamos un pseudocódigo de la rutina de atención a la int 33.}
\begin{lstlisting}[language={[x86masm]Assembler}]
global _isr33
_isr33:
    pushad
    xor eax, eax
    in al, 0x60
    push eax
    call print_numerito
    add esp, 4
    call fin_intr_pic1
    popad
    iret
\end{lstlisting}
\par{La instrucción \textbf{in al, 0x60} guarda en al el scan code almacenado en el puerto 0x60 y luego utilizamos esta información para escribir en pantalla con la función \textbf{print$\_$numerito}.}
\par{Esta función se encargará de llamar a las funciones auxiliares necesarias para cumplir con lo establecido al principio de esta sección, mostrar el mapa si se presionó la tecla M, y la información de estados si fue la E.}
\par{Más adelante en la sección \ref{subsec: Pantalla} veremos en profundidad las funciones que se encargan de la pantalla.}
\subsection{Int 80 (0x50)}
\par{Esta es una syscall que sólo pueden utilizar los navíos, es conciderado un error si una bandera la llama. Esta syscall cuenta con 3 funcionalidades; \textbf{navegar}, \textbf{fondear} y \textbf{cañonear}. Depende de los parámetros con los que es llamada se ejecutan las distintas funcionalidades.}
\par{A continuación presentamos un pseudocódigo de la rutina de atención a la interrupción, lo presentamos en lenguaje C para hacer más sencillo su entendimiento.}

\begin{algorithmic}
	\If{EAX == 0xAEF}
	\State navegar(current, cr3, ebx, ecx)
	\EndIf
	\If{EAX == 0x923}
		\State fondear(current, ebx, cr3)
	\EndIf
	\If{EAX == 0x83A}
	\State cañonear(current, ebx, ecx)
	\EndIf
\end{algorithmic}

\subsubsection{Navegar}
\par{Como su nombre lo indica, consiste en moverse a través del espacio marítimo, el cual en nuestro caso consiste en el espacio de memoria entre la dirección 0x100000 y la dirección 0x77FFFF. Los parámetros son 2 direcciones \textbf{físicas} las cuales serán mapeadas a las 2 páginas del navío respectivamente.}
\par{Para llamar a esta funcionalidad se debe escribir en EAX, 0xAEF. En EBX y ECX se pasan las direcciones físicas antes mencionadas.}
\par{A continuación presentamos un pseudocógido de la función navegar.}

\begin{algorithm}[h!]
\caption{void navegar(uint current, uint cr3, uint ebx, uint ecx)}
\begin{algorithmic}
	\State destinoPag1 = (unsigned char*) ebx
	\State destinoPag2 = (unsigned char*) ecx
	\State pagina1TareaActual = (unsigned char*) 0x40000000
	\State pagina2TareaActual = (unsigned char*) 0x40001000
	\For{ $i \gets 0~..~4095$ }
		\State destinoPag1[i] $\gets$ pagina1TareaActual
		\State destinoPag2[i] $\gets$ pagina2TareaActual
	\EndFor

	\State mmu$\_$mapear$\_$pagina(0x40000000, cr3, ebx)
	\State mmu$\_$mapear$\_$pagina(0x40001000, cr3,ecx)
	
	\State actualizar$\_$mapa(ebx,ecx,1,current)
	
\end{algorithmic}
\end{algorithm}

\par{La función actualizar mapa se define en la sección \ref{subsec: Pantalla}.}

\subsubsection{Fondear}
\par{Esta funcionalidad consiste en mover el ancla de lugar, y en nuestro TP consiste puntualmente en mapear la página asociada al kernel de nuestra tarea a otra dirección física entre el rango de 0x0x000000 hasta 0x0FFFFF.}
\par{Como ya vimos para llamar esta función EAX debe ser 0x923, y en EBX debemos pasar la nueva dirección \textbf{física} a mapear.}
\par{A continuación presentamos un pseudocógido de la función fondear.}

\begin{algorithm}[h!]
\caption{void fondear(uint current, uint ebx, uint cr3)}
\begin{algorithmic}
	\State mmu$\_$mapear$\_$pagina(0x40002000,ebx,cr3)
	\State actualizar$\_$mapa(ebx,0,0,current)
\end{algorithmic}
\end{algorithm}
\subsubsection{Cañonear}
\par{Cada uno de nuestros navíos cuenta con un cañon con el cual lanzar misiles. A esta funcionalidad se accede con EAX==0x83A y consiste en escribir 97 bytes desde la dirección pasada por EBX.}
\par{A continuación presentamos un pseudocógido de la función fondear.}

\begin{algorithm}[h!]
\caption{void canonear(uint current, uint ebx, uint ecx)}
\begin{algorithmic}
	\State misil = (unsigned char*) ecx
	\State destino = (unsigned char*) ebx
	\For (i $\gets 0~..~96$ )
	\State destino[i] $\gets$ misil[i]
	\EndFor
	\State actualizar$\_$mapa(ebx,0,2,current);
\end{algorithmic}
\end{algorithm}


	
\subsection{Int 102 (0x66)}
\par{Esta syscall se encarga de salir de las banderas y saltar a la tarea idle. También se fija que ha sido llamada por una bandera y no por un navío, ya que si fue así, a este habrá que eliminarlo del scheduler junto con su bandera.}